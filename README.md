
# GCP Starter-kit Template
This is a bare-bones template project for generating GCP CI/CD and Terraform manifests (Helm files, Spinnaker JSON, Cloudbuild.yaml, Terraform files for CloudBuild trigger) with project specific information. This is intended to be a framework/language agnostic template. 
This template repo also allows the _optional_ generation of:
* **NodeJS** example source code, package.json and a Docker file for a "Hello World" application
* **Java** example srouce code, pom.xml and a Docker file for a "Hello World" application
* **Python** example source code, requirements.txt, and a Docker file for a "Hello World" application

In addition to the basic "Hello World" template application, the following GCP Service implementation samples are provided:  
![cloudsql](https://user-images.githubusercontent.com/83463333/127359952-0c7f7a6b-bae4-4b4d-af10-b955862cafd3.png)
**CloudSQL for PostGres DB**   
This sample implements access to the GCP CloudSQL for PostgreSQL through SQL Proxy from GKE deployment. 

![memorystore](https://user-images.githubusercontent.com/83463333/127360341-6e269f3b-1826-4292-bfb6-ff941d04f339.png)
**Cloud Memorystore for Redis**  
This sample implements access to the GCP Memorystore for Redis from GKE deployment. This sample demonstrates how to add and read key-value data to GCP Memorystore for Redis. The sample Redis instance can be created by applying the generated Terraform script.

![storage](https://user-images.githubusercontent.com/83463333/127360568-15c8540e-52de-48d7-bc6d-58e5875f569a.png)
**Cloud Storage**  
This sample implements access to the GCP Storage from GKE deployment. This sample demonstrates how to connect to and list objects in a GCP Cloud Storage Bucket. The smaple bucket can be created by applying the generated Terraform script.

![firestore](https://user-images.githubusercontent.com/83463333/127360925-332b673f-0c6a-4c60-b43b-fb4fd2fa30e4.png)
**Cloud Firestore**  
This sample implements access to the GCP Firestore from GKE deployment. This sample demonstrates how to connect to GCP Firestore and Read / Write / List documents in a given collection. 

![pubsub](https://user-images.githubusercontent.com/59675732/131712466-0ae03bd3-93e1-41a9-9185-11ffbcd1d2f2.png)
**Cloud Pub/Sub**  
This sample implements access to the GCP PubSub from GKE deployment. This sample demonstrates how to subscribe to an existing GCP PubSub Topic and pull messages from an Existing Subscription. The Topic and Subscription can be created by applying the generated Terraform scripts.

![functions](https://user-images.githubusercontent.com/59675732/131712067-29e0ae29-245c-4ae4-af24-6d2480164df7.jpg)/![scheduler](https://user-images.githubusercontent.com/59675732/131712266-d008eea3-dbcd-4387-a858-2d7703bed44e.png)
**Cloud Functions and Cloud Scheduler**  
This sample implements a simple http function that displays a hello world message and logs a sample message to cloud logging. This sample demonstrates how to create a simple http triggered cloud function using the autogenerated terraform scripts. The sample also implements a simple scheduled job which calls the http function created in the above module every day a midnight.

# Before you begin  
Before you begin using this template, the following prerequisites must be met for each type of GCP service implementation:

**General Requirements:** GCP Project, GCP Namespace and Spinanker Service Account should already be acquired from TELUS CCoE.  
**CloudSQL:** CloudSQL API, CloudSQL Instance, Google Service Account (GSA), Kubernetes Service Account (KSA)  
**Memorystore:** Cloud Memorystore for Redis API  
**Cloud Storage:** Cloud Storage API  
**Firestore:** Cloud Firestore API
**Storage:** Cloud Storage API
**PubSub:** Cloud Pub/Sub API
**Function and Scheduler:** Cloud Functions API and Cloud Scheduler API

# Setup

### Create a repository from this template

1. Click the big green button `Use this template` or click <a href="../../generate">here</a>.
2. Enter a Repository name and click `Create repository from template`. _Tip: Use Telus/ as repository owner._
3. Head over to the created repository and complete the setup.

### Complete setup
Updated the 'cookiecutter.yaml' file to generate the project repository based on your settings.   
**Important:** A GitHub Action will be triggered as soon as the first commit is done to generate the manifests. The **fully populated** `cookiecutter.yaml` **should be the first commit**

### cookiecutter.yaml
The following general attributes defined in this file are used to generate all the manifests

**Note: If you do not have production configuration, please leave the YAML properties for production empty. Otherwise the GitHub action will break**
#### General Attributes (Mandatory)

Attribute | Description
------------ | -------------
name | Name of the Project/Application. This really only affects the readme file
application | Name of the application. Can be the same as name. Spinnaker pipelines and GKE Deployments will contain this name
namespace | GKE Namespace. _Provided by CCoE_
chart | HELM Chart Version# _Default: cio-gke-deployment-chart.0.5.0_
clusterNp | GKE Non Production Cluster. _Provided by CCoE_
clusterPr | GKE Production Cluster. _Provided by CCoE_
cmdbId | CMDB ID
costCentre | TELUS Cost Centre
organization | Usually "CIO"
mailingList | Any notifications will be sent here
spinnakerServiceAccount | Spinnaker Service Account. _Provided by CCoE_
port | The PORT that will be exposed via a service
gcpProjectIdNp | Non Production GCP Project ID. _Provided by CCoE_
gcpProjectIdPr | Production GCP Project ID. _Provided by CCoE_
gsa | GCP Service Account, created via terraform. see your project's terraform repository -> workload_identity.tf -> gsa_name: "gsa-${var.project_name}"
ksa | Kubernetes Service Account, created via terraform
dnsRequest | 'private' or 'public' to create a dns request yaml file. Leav empty for no dns request. follow instructions [here](https://developers.telus.com/guides/authenticating-users-in-an-end-user-facing-application?single-page=true) to submit your dns request"
githubRepo | The name of your project's GitHub repository
sonarSourcesDir | Path within your repo to your source code for Sonarqube analysissonarSourcesDir

### Sample Application
In addition to the above attributes, you may configure the cookiecutter.yaml file to have a sample _Hello-World_ application created based on one of the supported programming languages and GCP services.  
To generate the sample application, update the follwoing sections of the 'cookiecutter.yaml' file:

Attribute | Description
---------- | ------------
sampleApplication | Uncomment this section to generate the sample application
programmingLanguage | choose one of: 'java, nodejs, python'
gcpServiceSample | choose one of: 'basic, cloudpsql, pubsub, memstoreredis, gcstorage, firestore, cloudfunction'

### Optional GCP Service Scaffolding
The following sections of the cookiecutter.yaml file allow you to create the necessary helm entries and terraform scripts for each supported GCP service implementation. You may choose to configure additional services other than the one you selected for the sample application. However, at a minimum, you need to configure the service section for your sample application.


#### CloudSQL Attributes  
Attribute | Description
------------ | -------------
cloudpsql | Uncomment this section to generate the Terraform and Helm entries for CloudSQL.
cloudsqlConnNameNp | Non Production Connection name as seen in the GCP CloudSQL Console.  _valid format: project:region:instanceid-np-db_
cloudsqlConnNamePr | Production Connection name as seen in the GCP CloudSQL Console.  _valid format: project:region:instanceid-pr-db_  

[More Info on GCP CLoudSQL](https://cloud.google.com/sql/docs/postgres/instance-info#connect_to_this_instance)

#### Cloud Memorystore for Redis Attributes  
Attribute | Description
------------ | -------------
memstoreRedis | Uncomment this section to generate the Terraform and Helm entries for Memorystore for Redis.
redisIP | IP Address for the Redis Instance created in GCP Memorystore. 
redisPort | Redis Port. The default value is: "6379"

_Note_: If you already have an existing Redis instance to connect to, enter the IP address here.  You can obtain your Redis instance's IP address by navigating to your project's GCP Console, select Memorystore -> Redis.  
If you don't have an existing Redis instance, your Redis instance will be created once you copy the generated terraform file `memstore.tf` to your project's `tf-infra-` repository.  
Once the Redis instance is created, you need to update the generated `helm` chart files in the `/helm` folder of your repository to enter the IP address of your Redis instance.  

#### Cloud Storage Attributes  
Attribute | Description
------------ | -------------
gcstorage | Uncomment this section to generate the Terraform and Helm entries for Cloud Storage.
storageBucket | The name of your storage bucket to be created.


#### PubSub Attributes  
Attribute | Description
------------ | -------------
pubsub | Uncomment this section to generate the Terraform and Helm entries for PubSub.
topic | The name of your pubsub topic to be created. (_Default: "sample-topic-1"_)   
subscription | The name of your subscription to be created. (_Default: "sample-subscription-1"_)


#### Firesotre Attributes  
Attribute | Description
------------ | -------------
firestore | Uncomment this section to generate the Terraform and Helm entries for Firestore.
collectionName | The name of the sample collection in firestore db. (_Default: "sample-collection"_)   


# _NOTE_  
After the first commit of the cookiecutter.yaml file, the corresponding Terraform scripts will be available in the `/Terraform` folder of your new repository. The Terraform scripts are formatted based on the inputs you provided for each section of the cookiecutter.yaml file.  
It is important to copy the terraform files to your project's `tf-infra-` repository that has been created by CCoE. Follow the instructions provided [here](https://developers.telus.com/topics/applying-terraform-configuration-in-gcp) to apply the Terraform scripts to your project. 

### I have a repository and some source code. Now what?
1- Follow the instructions [here](https://developers.telus.com/topics/applying-terraform-configuration-in-gcp) to add the generated Terraform files to your project's 'tf-infra' repository.  
2- Login to your Spinnaker account and follow the instructions [here](https://developers.telus.com/topics/creating-a-continuous-delivery-pipeline-in-spinnaker) to create a new Pipeline for this project.  
3- Login to your GCP Project Console and follow the instructions [here](https://developers.telus.com/topics/connecting-cloudbuild-to-your-github-repository) to create a new Build Trigger for your Repository.  
4- Run the build trigger to build and deploy your application.  
